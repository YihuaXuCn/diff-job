functiondeposit(uint256[2]memorypublicKey)publicpayable
{
//Getamountsent
uint256receivedEther=floorEtherAndCheck(msg.value);
//Returnsnon-exactvalueETH
//Getsthevalueofthefirstdecimalplace
//inETHdeposited
//i.e.2.1willgive1,2.6willgive6
//ifit'sgreaterthan1,thenrefundthe
//amounts(we'llcount0.1ETHasadonationtoourrelayer;))
uint256etherDecimalVal=(msg.value/(1ether/10))%10;
if(etherDecimalVal>1){
uint256refundEtherDecimalVal=(etherDecimalVal-1)*(1ether/10);
relayerAddress.transfer(1ether/10);
msg.sender.transfer(refundEtherDecimalVal);
}
//Getsthecurrentringfortheamounts
uint256curIndex=ringsNo[receivedEther];
Ringstoragering=rings[receivedEther][curIndex];
if(!AltBn128.onCurve(uint256(publicKey[0]),uint256(publicKey[1]))){
revert("PublicKeynoonCurve");
}
//Makesurethatpublickey(stealthaddress)
//isn'talreadyinthere
for(uint8i=0;i<ring.dParticipantsNo;i++){
if(ring.publicKeys[i][0]==publicKey[0]&&
ring.publicKeys[i][1]==publicKey[1]){
revert("AddressalreadyincurrentRing");
}
}
//Ifitsanewring
//setcreatedBlockNumsize
if(ring.dParticipantsNo==0){
ring.createdBlockNumber=block.number-1;
}
//Updateringparams
ring.publicKeys[ring.dParticipantsNo]=publicKey;
ring.dParticipantsNo++;
ring.amountDeposited+=receivedEther;
//Createnewringifcurrentringhasexceedednumberofparticipants
if(ring.dParticipantsNo>=ringMaxParticipants){
//SetringHash
ring.ringHash=createRingHash(receivedEther/(1ether),curIndex);
//AddnewRingpool
ringsNo[receivedEther]+=1;
}
//BroadcastEvent
emitDeposited(msg.sender,receivedEther,curIndex);
}
