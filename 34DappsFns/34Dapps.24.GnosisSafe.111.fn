functionexecTransaction(
addressto,
uint256value,
bytescalldatadata,
Enum.Operationoperation,
uint256safeTxGas,
uint256baseGas,
uint256gasPrice,
addressgasToken,
addresspayablerefundReceiver,
bytesmemorysignatures
)publicpayablevirtualreturns(boolsuccess){
bytes32txHash;
//Usescopeheretolimitvariablelifetimeandprevent`stacktoodeep`errors
{
bytesmemorytxHashData=
encodeTransactionData(
//Transactioninfo
to,
value,
data,
operation,
safeTxGas,
//Paymentinfo
baseGas,
gasPrice,
gasToken,
refundReceiver,
//Signatureinfo
nonce
);
//Increasenonceandexecutetransaction.
nonce++;
txHash=keccak256(txHashData);
checkSignatures(txHash,txHashData,signatures);
}
addressguard=getGuard();
{
if(guard!=address(0)){
Guard(guard).checkTransaction(
//Transactioninfo
to,
value,
data,
operation,
safeTxGas,
//Paymentinfo
baseGas,
gasPrice,
gasToken,
refundReceiver,
//Signatureinfo
signatures,
msg.sender
);
}
}
//Werequiresomegastoemittheevents(atleast2500)aftertheexecutionandsometoperformcodeuntiltheexecution(500)
//Wealsoincludethe1/64inthecheckthatisnotsendalongwithacalltocounteractpotentialshortingsbecauseofEIP-150
require(gasleft()>=((safeTxGas*64)/63).max(safeTxGas+2500)+500,"GS010");
//Usescopeheretolimitvariablelifetimeandprevent`stacktoodeep`errors
{
uint256gasUsed=gasleft();
//IfthegasPriceis0weassumethatnearlyallavailablegascanbeused(itisalwaysmorethansafeTxGas)
//Weonlysubstract2500(comparedtothe3000before)toensurethattheamountpassedisstillhigherthansafeTxGas
success=execute(to,value,data,operation,gasPrice==0?(gasleft()-2500):safeTxGas);
gasUsed=gasUsed.sub(gasleft());
//IfnosafeTxGasandnogasPricewasset(e.g.bothare0),thentheinternaltxisrequiredtobesuccessful
//Thismakesitpossibletouse`estimateGas`withoutissues,asitsearchesfortheminimumgaswherethetxdoesn'trevert
require(success||safeTxGas!=0||gasPrice!=0,"GS013");
//Wetransferthecalculatedtxcoststothetx.origintoavoidsendingittointermediatecontractsthathavemadecalls
uint256payment=0;
if(gasPrice>0){
payment=handlePayment(gasUsed,baseGas,gasPrice,gasToken,refundReceiver);
}
if(success)emitExecutionSuccess(txHash,payment);
elseemitExecutionFailure(txHash,payment);
}
{
if(guard!=address(0)){
Guard(guard).checkAfterExecution(txHash,success);
}
}
}
