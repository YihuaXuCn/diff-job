functionbuyBooster(uint256idx)publicisNotOverisCurrentRound(msg.sender)payable
{
require(idx<numberOfBoosts);
BoostDatastorageb=boostData[idx];
if(msg.value<getBoosterPrice(idx)||msg.sender==b.owner){
revert();
}
addressbeneficiary=b.owner;
uint256devFeePrize=devFee(getBoosterPrice(idx));
addressgameSponsor=Engineer.gameSponsor();
gameSponsor.transfer(devFeePrize);
uint256refundPrize=0;
if(beneficiary!=0){
refundPrize=SafeMath.div(SafeMath.mul(getBoosterPrice(idx),55),100);
asyncSend(beneficiary,refundPrize);
boosterReward[beneficiary]=SafeMath.add(boosterReward[beneficiary],refundPrize);
}
prizePool=SafeMath.add(prizePool,SafeMath.sub(msg.value,SafeMath.add(devFeePrize,refundPrize)));
updateCrystal(msg.sender);
updateCrystal(beneficiary);
uint256level=getCurrentLevel(b.startingLevel,b.startingTime,b.halfLife);
b.startingLevel=SafeMath.add(level,1);
b.startingTime=now;
b.owner=msg.sender;
emitBuyBooster(msg.sender,roundNumber,idx,msg.value,beneficiary,refundPrize);
}
