functionwithdraw(
addresspayablereceiver,uint256amountEther,uint256index,
uint256c0,uint256[2]memorykeyImage,uint256[]memorys
)public
{
uinti;
uint256startGas=gasleft();
//Getamountsentinwholenumber
uint256withdrawEther=floorEtherAndCheck(amountEther*1ether);
//Getsthecurrentring,giventheamountandidx
Ringstoragering=rings[withdrawEther][index];
if(receiver==0x0000000000000000000000000000000000000000){
revert("Nozeroaddressreceiver");
}
//Ifeveryonehaswithdrawn
if(ring.wParticipantsNo>=ringMaxParticipants){
revert("AllfundsfromcurrentRinghasbeenwithdrawn");
}
//Ringneedstobeclosedfirst
if(ring.ringHash==bytes32(0x00)){
revert("Ringisn'tclosed");
}
//Convertpublickeytodynamicarray
//Basedonnumberofpeoplewhohave
//deposited
uint256[2][]memorypublicKeys=newuint256[2][](ring.dParticipantsNo);
for(i=0;i<ring.dParticipantsNo;i++){
publicKeys[i]=[
uint256(ring.publicKeys[uint8(i)][0]),
uint256(ring.publicKeys[uint8(i)][1])
];
}
//Attemptstoverifyringsignature
boolsignatureVerified=LSAG.verify(
abi.encodePacked(ring.ringHash,receiver),//Converttobytes
c0,
keyImage,
s,
publicKeys
);
if(!signatureVerified){
revert("Invalidsignature");
}
//ChecksifKeyImagehasbeenused
//AKANodoublewithdraw
for(i=0;i<ring.wParticipantsNo;i++){
if(ring.keyImages[uint8(i)][0]==keyImage[0]&&
ring.keyImages[uint8(i)][1]==keyImage[1]){
revert("Signaturehasbeenused!");
}
}
//Otherwiseaddskeyimagetothecurrentkeyimage
//Andadjustsparamsaccordingly
ring.keyImages[ring.wParticipantsNo]=keyImage;
ring.wParticipantsNo+=1;
//SendETHtoreceiver
//CalculategasUsagefees
uint256gasUsed=(startGas-gasleft())*tx.gasprice;
//Calculaterelayerfees(1.33%)
uint256relayerFees=(withdrawEther/75);
//Totalfees
uint256fees=gasUsed+relayerFees;
//Relayergetscompensated
msg.sender.transfer(fees);
//RecieverthengetstheremainingETH
receiver.transfer(withdrawEther-fees);
}
