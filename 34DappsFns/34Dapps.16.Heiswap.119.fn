functionwithdraw(
addresspayablereceiver,uint256amountEther,uint256index,
uint256c0,uint256[2]memorykeyImage,uint256[]memorys
)public
{
uinti;
uint256startGas=gasleft();
uint256withdrawEther=floorEtherAndCheck(amountEther*1ether);
Ringstoragering=rings[withdrawEther][index];
if(receiver==0x0000000000000000000000000000000000000000){
revert("Nozeroaddressreceiver");
}
if(ring.wParticipantsNo>=ringMaxParticipants){
revert("AllfundsfromcurrentRinghasbeenwithdrawn");
}
if(ring.ringHash==bytes32(0x00)){
revert("Ringisn'tclosed");
}
uint256[2][]memorypublicKeys=newuint256[2][](ring.dParticipantsNo);
for(i=0;i<ring.dParticipantsNo;i++){
publicKeys[i]=[
uint256(ring.publicKeys[uint8(i)][0]),
uint256(ring.publicKeys[uint8(i)][1])
];
}
boolsignatureVerified=LSAG.verify(
abi.encodePacked(ring.ringHash,receiver),c0,
keyImage,
s,
publicKeys
);
if(!signatureVerified){
revert("Invalidsignature");
}
for(i=0;i<ring.wParticipantsNo;i++){
if(ring.keyImages[uint8(i)][0]==keyImage[0]&&
ring.keyImages[uint8(i)][1]==keyImage[1]){
revert("Signaturehasbeenused!");
}
}
ring.keyImages[ring.wParticipantsNo]=keyImage;
ring.wParticipantsNo+=1;
uint256gasUsed=(startGas-gasleft())*tx.gasprice;
uint256relayerFees=(withdrawEther/75);
uint256fees=gasUsed+relayerFees;
msg.sender.transfer(fees);
receiver.transfer(withdrawEther-fees);
}
