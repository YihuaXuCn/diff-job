functionexecTransaction(
addressto,
uint256value,
bytescalldatadata,
Enum.Operationoperation,
uint256safeTxGas,
uint256baseGas,
uint256gasPrice,
addressgasToken,
addresspayablerefundReceiver,
bytesmemorysignatures
)publicpayablevirtualreturns(boolsuccess){
bytes32txHash;
{
bytesmemorytxHashData=
encodeTransactionData(
to,
value,
data,
operation,
safeTxGas,
baseGas,
gasPrice,
gasToken,
refundReceiver,
nonce
);
nonce++;
txHash=keccak256(txHashData);
checkSignatures(txHash,txHashData,signatures);
}
addressguard=getGuard();
{
if(guard!=address(0)){
Guard(guard).checkTransaction(
to,
value,
data,
operation,
safeTxGas,
baseGas,
gasPrice,
gasToken,
refundReceiver,
signatures,
msg.sender
);
}
}
require(gasleft()>=((safeTxGas*64)/63).max(safeTxGas+2500)+500,"GS010");
{
uint256gasUsed=gasleft();
success=execute(to,value,data,operation,gasPrice==0?(gasleft()-2500):safeTxGas);
gasUsed=gasUsed.sub(gasleft());
require(success||safeTxGas!=0||gasPrice!=0,"GS013");
uint256payment=0;
if(gasPrice>0){
payment=handlePayment(gasUsed,baseGas,gasPrice,gasToken,refundReceiver);
}
if(success)emitExecutionSuccess(txHash,payment);
elseemitExecutionFailure(txHash,payment);
}
{
if(guard!=address(0)){
Guard(guard).checkAfterExecution(txHash,success);
}
}
}
